{{template "header" .}}
<style>
    main {
        padding: 2rem;
        width: clamp(300px, 95%, 1400px);
        margin: 0 auto;
        height: 88vh;
        overflow-y: auto;
        display: flex; /* Make main a flex container */
        gap: 20px; /* Space between main content and sidebar */
    }
    
    .content-wrapper {
        flex: 1; /* Take up available space */
        min-width: 0; /* Prevent flex items from overflowing */
    }
    
    .main-container {
        width: 100%;
        height: clamp(300px, 80%, 800px);
        background-color: var(--container-color);
        margin-bottom: 30px;
        display: inline-block;
        position: relative;
    }

    .sidebar {
        display: none;
        width: 300px; /* Fixed width for sidebar */
        background-color: var(--accent-color); /* Blue background */
        background-color: var(--container-color);
        padding: 15px;
        border-radius: 5px;
        height: fit-content;
        flex-shrink: 0; /* Prevent sidebar from shrinking */
    }
    
    .tab-navigation{
        display: flex;
        gap: 0px;
        background-color: var(--accent-color);
    }
    .tab-container {
      padding: 0px;
    }
    .tab-navigation button {
        min-width: 100px;
        width: auto;
        padding: 16px 32px;
        border: none;
        font-size: 1rem;
        cursor: pointer;
        background: var(--accent-colors);
        color: var(--background-color);
    }
    .tab-navigation button.active {
        background: var(--container-color);
        color: var(--text-color);
    }
    .tab-content {
        display: none;
        padding: 16px;
    }
    .tab-content.active {
        display: block;
    }
    
    
    #main-etl-timeline {
        width: 100%;
            height: 100%;
            display: block; /* Removes extra spacing */
            position: absolute;
            top: 0;
            left: 0;
    }
    #side-etl-timeline{
        width: 260px;
    }

    .query-toggle {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        align-items: center;
        background: rgba(255,255,255,0.8);
        padding: 5px 10px;
        border-radius: 5px;
    }
    
    .switch {
        position: relative;
        display: inline-block;
        width: 40px;
        height: 22px;
        margin-right: 10px;
    }
    
    .switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    
    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: .4s;
    }
    
    .slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: .4s;
    }
    
    input:checked + .slider {
        background-color: #2196F3;
    }
    
    input:checked + .slider:before {
        transform: translateX(18px);
    }
    
    .slider.round {
        border-radius: 22px;
    }
    
    .slider.round:before {
        border-radius: 50%;
    }
    .side-flex{
        background-color: var(--container-color);
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        height: 100%;
    }
    .main-editor {
        width: 100%;
        height: 100%;
        background-color: var(--container-color);
        padding: 20px;
        overflow: auto;
    }
    
    .data-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
        margin-bottom: 30px;
    }
    
    .data-table th, .data-table td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }
    
    .data-table th {
        background-color: #f2f2f2;
        position: sticky;
        top: 0;
    }
    
    .data-table tbody tr:nth-child(even) {
        background-color: rgba(0,0,0,0.02);
    }
    
    .data-table tbody tr:hover {
        background-color: rgba(0,0,0,0.05);
    }
    
    #history {
        width: 100%;
        height: 300px;
        font-family: monospace;
        padding: 10px;
        margin-top: 20px;
        background-color: #f8f8f8;
        color: var(--text-color);
        border: 1px solid #ddd;
        border-radius: 4px;
    }
    
    .tab-content {
        max-height: 600px;
        overflow-y: auto;
    }
    
    /* Utility classes for statistics in the Performance section */
    .metric-card {
        text-align: center;
        transition: transform 0.2s;
    }
    
    .metric-card:hover {
        transform: translateY(-5px);
    }
    
</style>

<main>
    <div class="content-wrapper">
        <div class="main-container">
            <div class="main-timeline">
                <canvas id="main-etl-timeline"></canvas>
                <div class="query-toggle">
                <label class="switch">
                    <input type="checkbox" id="query-toggle" title="Toggle to show or hide queries">
                    <span class="slider round"></span>
                </label>
                <span>Show Queries</span>
                </div>
                <div id="node-tooltip" style="display: none; position: absolute; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 5px; pointer-events: none; z-index: 10;"></div>
            </div>
            <div class="main-editor" style="display: none;">
            </div>
        </div>

        <div class="container tab-container cont-performance">
            <div class="tab-navigation">
                <button data-tab="1">Refreshes</button>
                <button data-tab="2">Performance</button>
            </div>
            <div class="tab-contents">
                <div class="tab-content" data-tab="1">Content for Container 1, Tab 1</div>
                <div class="tab-content" data-tab="2">Content for Container 1, Tab 2</div>
            </div>  
        </div>
    </div>

    <section class="sidebar">
        <div class="side-flex">
            <button class="btn btn-primary close" onclick="
            document.querySelector('.sidebar').style.display = 'none';
            document.querySelector('main').style.removeProperty('justify-content');">Close</button>

            <div class="side-timeline">
                <canvas id="side-etl-timeline"></canvas>
            </div>
            <div class="pipeline-history">
                <textarea name="history" id="history" cols="30" rows="10" placeholder="Pipeline history"></textarea>
            </div>
        </div>
    </section>
</main>

<script>
    console.log("ETL Pipeline Visualization Loaded");

    // Utility to generate random data with factory context
    const generateFakeData = () => {
        const randomDate = () => {
            const start = new Date(2024, 0, 1);
            const end = new Date();
            return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
        };
        
        const randomTime = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);
        
        return {
            // Generate refresh history data
            refreshHistory: Array.from({ length: 20 }, (_, i) => ({
                id: `refresh-${i+1}`,
                datasource: ['Assembly Line', 'Quality Control', 'Materials', 'Machinery', 'Production'][Math.floor(Math.random() * 5)],
                refreshTime: randomDate().toISOString(),
                refreshType: Math.random() > 0.7 ? 'Full Recomputation' : 'Incremental',
                status: Math.random() > 0.8 ? 'Failed' : 'Success',
                duration: `${randomTime(5, 120)} min`
            })),
            
            // Generate failures data for factory processes
            failedProcesses: Array.from({ length: 8 }, (_, i) => ({
                id: `failure-${i+1}`,
                step: ['Data Extraction', 'Schema Validation', 'Data Transformation', 'Type Conversion', 'Loading'][Math.floor(Math.random() * 5)],
                datasource: ['Assembly Line', 'Quality Control', 'Materials', 'Machinery', 'Production'][Math.floor(Math.random() * 5)],
                crashTime: randomDate().toISOString(),
                errorMessage: [
                    'Schema validation failed: Missing required column "part_id"',
                    'Connection timeout while accessing machine sensors',
                    'Data type mismatch: Expected numeric value for temperature',
                    'Memory allocation error during assembly line data processing',
                    'Foreign key constraint violation while loading maintenance data'
                ][Math.floor(Math.random() * 5)]
            })),
            
            // Performance metrics for factory systems
            performanceMetrics: {
                avgThroughput: `${(Math.random() * 100 + 50).toFixed(2)} parts/min`,
                avgLatency: `${(Math.random() * 200 + 10).toFixed(2)} ms`,
                errorRate: `${(Math.random() * 5).toFixed(2)}%`,
                totalDataStored: `${(Math.random() * 1000 + 100).toFixed(2)} GB`,
                avgPipelineTime: `${randomTime(10, 60)} minutes`
            },
            
            // Serving layer stats for factory data
            servingLayers: Array.from({ length: 5 }, (_, i) => ({
                name: ['Production Dashboard', 'Quality Metrics', 'Machine Status', 'Inventory Levels', 'Maintenance Schedule'][i],
                dataStored: `${(Math.random() * 100 + 10).toFixed(2)} GB`,
                lastRefresh: randomDate().toISOString(),
                avgRefreshTime: `${randomTime(3, 30)} minutes`,
                queryCount: Math.floor(Math.random() * 10000),
                refreshFrequency: ['Hourly', 'Daily', 'Weekly', '6 Hours', 'Bi-daily'][Math.floor(Math.random() * 5)]
            }))
        };
    };

    // Create a factory-focused ETL pipeline
    const createEtlPipeline = () => {
        const nodes = [];
        const edges = [];
        
        // Data source layer (extraction) - factory data sources
        const dataSources = [
            { id: 'src1', name: 'Assembly Line', type: 'source', x: 100, y: 80, width: 60, height: 60, 
              details: 'Assembly line sensor data', 
              schema: [
                { name: 'timestamp', type: 'date' },
                { name: 'station_id', type: 'string' },
                { name: 'product_id', type: 'string' },
                { name: 'cycle_time', type: 'float' },
                { name: 'status', type: 'string' }
              ],
              code: 'SELECT * FROM factory.assembly_line WHERE timestamp > :last_extract_date'
            },
            { id: 'src2', name: 'Quality Control', type: 'source', x: 250, y: 80, width: 60, height: 60, 
              details: 'Quality inspection data', 
              schema: [
                { name: 'inspection_id', type: 'string' },
                { name: 'product_id', type: 'string' },
                { name: 'result', type: 'string' },
                { name: 'timestamp', type: 'date' },
                { name: 'inspector_id', type: 'string' }
              ],
              code: 'SELECT * FROM factory.quality_control WHERE timestamp > :last_extract_date'
            },
            { id: 'src3', name: 'Machinery', type: 'source', x: 400, y: 80, width: 60, height: 60, 
              details: 'Machine status and telemetry', 
              schema: [
                { name: 'machine_id', type: 'string' },
                { name: 'status', type: 'string' },
                { name: 'temperature', type: 'float' },
                { name: 'vibration', type: 'float' },
                { name: 'timestamp', type: 'date' }
              ],
              code: 'SELECT * FROM factory.machinery WHERE timestamp > :last_extract_date'
            },
            { id: 'src4', name: 'Materials', type: 'source', x: 550, y: 80, width: 60, height: 60, 
              details: 'Raw materials inventory', 
              schema: [
                { name: 'material_id', type: 'string' },
                { name: 'name', type: 'string' },
                { name: 'quantity', type: 'integer' },
                { name: 'location', type: 'string' },
                { name: 'last_update', type: 'date' }
              ],
              code: 'SELECT * FROM factory.materials WHERE last_update > CURRENT_DATE - 90'
            }
        ];
        
        nodes.push(...dataSources);
        
        // Schema validation nodes
        dataSources.forEach((source, i) => {
            const schemaNode = {
                id: `schema${i+1}`,
                name: 'Schema Validation',
                type: 'extraction',
                x: source.x,
                y: source.y + 110,
                width: 50,
                height: 50,
                details: `Validate ${source.name} schema`,
                parentId: source.id,
                schema: source.schema,
                code: `-- Schema validation for ${source.name}
    VALIDATE TABLE structure (
        ${source.schema.map(col => `${col.name} ${col.type}`).join(',\n    ')}
    )`
            };
            
            nodes.push(schemaNode);
            edges.push({ from: source.id, to: schemaNode.id });
        });
        
        // Transformation nodes - for factory data
        const transformations = [
            // Assembly line data transformations
            { id: 't1', name: 'Clean Assembly', type: 'transformation', x: 100, y: 240, width: 50, height: 50, 
              details: 'Normalize assembly line data',
              code: `-- Clean assembly line data
    SELECT 
        timestamp,
        station_id,
        product_id,
        ROUND(cycle_time, 2) AS cycle_time,
        status
    FROM assembly_line_raw
    WHERE cycle_time > 0`,
              schema: [
                { name: 'timestamp', type: 'date' },
                { name: 'station_id', type: 'string' },
                { name: 'product_id', type: 'string' },
                { name: 'cycle_time', type: 'float' },
                { name: 'status', type: 'string' }
              ]
            },
            
            // Quality data transformations
            { id: 't2', name: 'Clean Quality', type: 'transformation', x: 250, y: 240, width: 50, height: 50, 
              details: 'Clean quality inspection data',
              code: `-- Clean quality control data
    SELECT 
        inspection_id,
        product_id,
        UPPER(result) AS result,
        timestamp,
        inspector_id
    FROM quality_control_raw`,
              schema: [
                { name: 'inspection_id', type: 'string' },
                { name: 'product_id', type: 'string' },
                { name: 'result', type: 'string' },
                { name: 'timestamp', type: 'date' },
                { name: 'inspector_id', type: 'string' }
              ]
            },
            { id: 't3', name: 'Defect Analysis', type: 'transformation', x: 250, y: 310, width: 50, height: 50, 
              details: 'Analyze product defects',
              code: `-- Analyze defect patterns
    SELECT 
        q.product_id,
        COUNT(*) as defect_count,
        STRING_AGG(q.inspection_id, ',') as inspections,
        MIN(q.timestamp) as first_defect,
        MAX(q.timestamp) as last_defect
    FROM clean_quality q
    WHERE q.result = 'FAIL'
    GROUP BY q.product_id`,
              schema: [
                { name: 'product_id', type: 'string' },
                { name: 'defect_count', type: 'integer' },
                { name: 'inspections', type: 'string' },
                { name: 'first_defect', type: 'date' },
                { name: 'last_defect', type: 'date' }
              ]
            },
            
            // Machinery transformations
            { id: 't4', name: 'Clean Machinery', type: 'transformation', x: 400, y: 240, width: 50, height: 50, 
              details: 'Process machine telemetry',
              code: `-- Clean machinery data
    SELECT 
        machine_id,
        status,
        ROUND(temperature, 1) AS temperature,
        ROUND(vibration, 3) AS vibration,
        timestamp
    FROM machinery_raw
    WHERE temperature BETWEEN 0 AND 150`,
              schema: [
                { name: 'machine_id', type: 'string' },
                { name: 'status', type: 'string' },
                { name: 'temperature', type: 'float' },
                { name: 'vibration', type: 'float' },
                { name: 'timestamp', type: 'date' }
              ]
            },
            
            // Materials transformations
            { id: 't5', name: 'Clean Materials', type: 'transformation', x: 550, y: 240, width: 50, height: 50, 
              details: 'Normalize materials data',
              code: `-- Clean materials data
    SELECT 
        material_id,
        TRIM(name) AS name,
        quantity,
        location,
        last_update
    FROM materials_raw
    WHERE quantity >= 0`,
              schema: [
                { name: 'material_id', type: 'string' },
                { name: 'name', type: 'string' },
                { name: 'quantity', type: 'integer' },
                { name: 'location', type: 'string' },
                { name: 'last_update', type: 'date' }
              ]
            },
            
            // Production Status aggregation
            { id: 't6', name: 'Production Status', type: 'transformation', x: 330, y: 380, width: 50, height: 50, 
              details: 'Aggregate production metrics',
              code: `-- Create production status view
    SELECT 
        a.station_id,
        COUNT(a.product_id) AS products_processed,
        AVG(a.cycle_time) AS avg_cycle_time,
        SUM(CASE WHEN q.result = 'PASS' THEN 1 ELSE 0 END) AS passed_quality,
        SUM(CASE WHEN q.result = 'FAIL' THEN 1 ELSE 0 END) AS failed_quality,
        MAX(a.timestamp) AS last_activity
    FROM clean_assembly a
    LEFT JOIN clean_quality q ON a.product_id = q.product_id
    GROUP BY a.station_id`,
              schema: [
                { name: 'station_id', type: 'string' },
                { name: 'products_processed', type: 'integer' },
                { name: 'avg_cycle_time', type: 'float' },
                { name: 'passed_quality', type: 'integer' },
                { name: 'failed_quality', type: 'integer' },
                { name: 'last_activity', type: 'date' }
              ]
            }
        ];
        
        nodes.push(...transformations);
        
        // Connect schema validation nodes to transformations
        edges.push(
            { from: 'schema1', to: 't1' }, // Assembly schema to Assembly transformation
            { from: 'schema2', to: 't2' }, // Quality schema to Quality transformation
            { from: 'schema3', to: 't4' }, // Machinery schema to Machinery transformation
            { from: 'schema4', to: 't5' }  // Materials schema to Materials transformation
        );
        
        // Connect transformations in sequence
        edges.push(
            { from: 't2', to: 't3' }, // Clean Quality to Defect Analysis
            { from: 't1', to: 't6' }, // Clean Assembly to Production Status
            { from: 't3', to: 't6' }, // Defect Analysis to Production Status
            { from: 't4', to: 't3' }  // Clean Machinery to Defect Analysis
        );
        
        // Load nodes - final output tables
        const loadNodes = [
            { id: 'l1', name: 'Production Dashboard', type: 'load', x: 180, y: 500, width: 70, height: 60, 
              details: 'Factory production dashboard',
              code: `-- Load Production Dashboard
    INSERT INTO prod.production_dashboard
    SELECT * FROM production_status_view`,
              schema: [
                { name: 'station_id', type: 'string' },
                { name: 'products_processed', type: 'integer' },
                { name: 'avg_cycle_time', type: 'float' },
                { name: 'passed_quality', type: 'integer' },
                { name: 'failed_quality', type: 'integer' },
                { name: 'last_activity', type: 'date' }
              ],
              stats: {
                dataStored: '42.3 GB',
                lastRefresh: '2025-03-25T14:30:00Z',
                avgRefreshTime: '18 minutes',
                queryCount: 4231,
                refreshFrequency: 'Hourly'
              }
            },
            { id: 'l2', name: 'Quality Metrics', type: 'load', x: 330, y: 500, width: 70, height: 60, 
              details: 'Quality control metrics',
              code: `-- Load Quality Metrics
    INSERT INTO prod.quality_metrics
    SELECT * FROM defect_analysis`,
              schema: [
                { name: 'product_id', type: 'string' },
                { name: 'defect_count', type: 'integer' },
                { name: 'inspections', type: 'string' },
                { name: 'first_defect', type: 'date' },
                { name: 'last_defect', type: 'date' }
              ],
              stats: {
                dataStored: '78.6 GB',
                lastRefresh: '2025-03-26T08:15:00Z',
                avgRefreshTime: '23 minutes',
                queryCount: 6842,
                refreshFrequency: 'Daily'
              }
            },
            { id: 'l3', name: 'Machine Status', type: 'load', x: 480, y: 500, width: 70, height: 60, 
              details: 'Real-time machine status',
              code: `-- Load Machine Status
    INSERT INTO prod.machine_status
    SELECT * FROM clean_machinery`,
              schema: [
                { name: 'machine_id', type: 'string' },
                { name: 'status', type: 'string' },
                { name: 'temperature', type: 'float' },
                { name: 'vibration', type: 'float' },
                { name: 'timestamp', type: 'date' }
              ],
              stats: {
                dataStored: '112.8 GB',
                lastRefresh: '2025-03-26T06:45:00Z',
                avgRefreshTime: '8 minutes',
                queryCount: 7517,
                refreshFrequency: '10 Minutes'
              }
            }
        ];
        
        nodes.push(...loadNodes);
        
        // Connect transformations to loads
        edges.push(
            { from: 't6', to: 'l1' }, // Production Status to Production Dashboard
            { from: 't3', to: 'l2' }, // Defect Analysis to Quality Metrics
            { from: 't4', to: 'l3' }  // Clean Machinery to Machine Status
        );
        
        // Query nodes (usage examples)
        const queryNodes = [
            { id: 'q1', name: 'Efficiency Report', type: 'query', x: 180, y: 600, width: 60, height: 40, 
              details: 'Station efficiency report',
              code: `SELECT * FROM production_dashboard ORDER BY avg_cycle_time ASC` },
            { id: 'q2', name: 'Quality Issues', type: 'query', x: 330, y: 600, width: 60, height: 40, 
              details: 'Top quality issues',
              code: `SELECT product_id, defect_count
    FROM quality_metrics
    ORDER BY defect_count DESC
    LIMIT 10` },
            { id: 'q3', name: 'Overheating Alert', type: 'query', x: 480, y: 600, width: 60, height: 40, 
              details: 'Machines with temperature alerts',
              code: `SELECT * FROM machine_status WHERE temperature > 85` }
        ];
        
        nodes.push(...queryNodes);
        
        // Connect load to queries
        edges.push(
            { from: 'l1', to: 'q1' },
            { from: 'l2', to: 'q2' },
            { from: 'l3', to: 'q3' }
        );
        
        return { nodes, edges };
    };

    // Initialize the canvas
    const canvas = document.getElementById('main-etl-timeline');
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    const ctx = canvas.getContext('2d');

    // Generate pipeline data
    const pipelineData = createEtlPipeline();

    // Generate fake metrics and stats
    const fakeData = generateFakeData();

    // Pan and zoom state
    let panOffset = { x: 0, y: 0 };
    let scale = 1;
    let isDragging = false;
    let lastMousePos = { x: 0, y: 0 };
    let selectedNode = null;
    const tooltip = document.getElementById('node-tooltip');
    const queryToggle = document.getElementById('query-toggle');
    let showQueries = false;

    // Section heights
    const sectionHeight = canvas.height / 4;

    // Node detail container elements
    const nodeDetailContainer = document.querySelector('.main-editor');
    const nodeNameElement = document.createElement('h2');
    const nodeSqlElement = document.createElement('pre');
    const nodeDataTable = document.createElement('table');
    nodeDataTable.className = 'data-table';

    // Function to draw the ETL pipeline
    function drawPipeline() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Apply transformations
        ctx.save();
        ctx.translate(panOffset.x, panOffset.y);
        ctx.scale(scale, scale);

        // Draw sections
        drawSections();

        // Draw edges
        drawEdges();

        // Draw nodes
        drawNodes();

        ctx.restore();
    }

    // Draw section backgrounds and labels
    function drawSections() {
        const sections = ['Extraction', 'Transformation', 'Loading', 'Query'];
        const colors = ['rgba(200,230,200,0.3)', 'rgba(200,200,230,0.3)', 'rgba(230,200,200,0.3)', 'rgba(230,230,200,0.3)'];

        for (let i = 0; i < sections.length; i++) {
            // Skip query section if toggle is off
            if (i === 3 && !showQueries) continue;

            const y = i * sectionHeight / scale;
            const height = sectionHeight / scale;

            // Draw section background
            ctx.fillStyle = colors[i];
            ctx.fillRect(0, y, canvas.width / scale, height);

            // Draw section label
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.font = `${16 / scale}px Arial`;
            ctx.fillText(sections[i], 10, y + 30 / scale);
        }
    }

    // Draw nodes
    function drawNodes() {
        pipelineData.nodes.forEach(node => {
            // Skip query nodes if toggle is off
            if (node.type === 'query' && !showQueries) return;

            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1 / scale;

            // Use squares for data sources, circles for process nodes
            if (node.type === 'source') {
                // Draw as square for data sources
                ctx.fillStyle = getNodeColor(node.type);
                ctx.beginPath();
                ctx.rect(node.x, node.y, node.width, node.height);
                ctx.fill();
                ctx.stroke();

                // Show name for data sources
                ctx.fillStyle = 'black';
                ctx.font = `${12 / scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(node.name, node.x + node.width / 2, node.y + node.height / 2);
            } else {
                // Draw as circle for process nodes
                const radius = node.width / 2;
                ctx.fillStyle = getNodeColor(node.type);
                ctx.beginPath();
                ctx.arc(node.x + radius, node.y + radius, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Show abbreviated name for process nodes
                ctx.fillStyle = 'black';
                ctx.font = `${10 / scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(node.id, node.x + radius, node.y + radius);
            }

            // Highlight selected node
            if (selectedNode && node.id === selectedNode.id) {
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 3 / scale;
                if (node.type === 'source') {
                    ctx.strokeRect(node.x, node.y, node.width, node.height);
                } else {
                    const radius = node.width / 2;
                    ctx.beginPath();
                    ctx.arc(node.x + radius, node.y + radius, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        });
    }

    // Draw edges between nodes
    function drawEdges() {
        pipelineData.edges.forEach(edge => {
            const fromNode = pipelineData.nodes.find(n => n.id === edge.from);
            const toNode = pipelineData.nodes.find(n => n.id === edge.to);

            // Skip edges to/from query nodes if toggle is off
            if ((fromNode.type === 'query' || toNode.type === 'query') && !showQueries) return;

            ctx.strokeStyle = 'rgba(100,100,100,0.7)';
            ctx.lineWidth = 2 / scale;

            // Calculate start and end points
            let startX, startY, endX, endY;

            if (fromNode.type === 'source') {
                startX = fromNode.x + fromNode.width / 2;
                startY = fromNode.y + fromNode.height;
            } else {
                const radius = fromNode.width / 2;
                startX = fromNode.x + radius;
                startY = fromNode.y + radius;

                // Adjust based on direction to next node
                const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
                startX += Math.cos(angle) * radius;
                startY += Math.sin(angle) * radius;
            }

            if (toNode.type === 'source') {
                endX = toNode.x + toNode.width / 2;
                endY = toNode.y;
            } else {
                const radius = toNode.width / 2;
                endX = toNode.x + radius;
                endY = toNode.y + radius;

                // Adjust based on direction from previous node
                const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
                endX -= Math.cos(angle) * radius;
                endY -= Math.sin(angle) * radius;
            }

            // Draw the line
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            // Draw arrow
            const arrowSize = 5 / scale;
            const angle = Math.atan2(endY - startY, endX - startX);

            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - arrowSize * Math.cos(angle - Math.PI / 6),
                endY - arrowSize * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                endX - arrowSize * Math.cos(angle + Math.PI / 6),
                endY - arrowSize * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();
        });
    }

    // Get node color based on type
    function getNodeColor(type) {
        switch (type) {
            case 'source': return 'rgba(80,180,80,0.8)';
            case 'extraction': return 'rgba(120,200,120,0.8)';
            case 'transformation': return 'rgba(100,100,200,0.8)';
            case 'load': return 'rgba(200,100,100,0.8)';
            case 'query': return 'rgba(200,200,100,0.8)';
            default: return 'rgba(150,150,150,0.8)';
        }
    }

    // Check if mouse is over a node
    function getNodeAtPosition(x, y) {
        // Adjust coordinates for pan and zoom
        x = (x - panOffset.x) / scale;
        y = (y - panOffset.y) / scale;

        for (let i = pipelineData.nodes.length - 1; i >= 0; i--) {
            const node = pipelineData.nodes[i];

            // Skip query nodes if toggle is off
            if (node.type === 'query' && !showQueries) continue;

            if (node.type === 'source') {
                // Square hit detection for data sources
                if (x >= node.x && x <= node.x + node.width &&
                    y >= node.y && y <= node.y + node.height) {
                    return node;
                }
            } else {
                // Circle hit detection for process nodes
                const radius = node.width / 2;
                const centerX = node.x + radius;
                const centerY = node.y + radius;
                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));

                if (distance <= radius) {
                    return node;
                }
            }
        }
        return null;
    }

    // Render node details when a node is clicked
    function renderNodeDetails(node) {
        // Show the node details container
        const mainTimeline = document.querySelector('.main-timeline');
        const mainEditor = document.querySelector('.main-editor');

        mainTimeline.style.display = 'none';
        mainEditor.style.display = 'block';

        // Clear previous content
        mainEditor.innerHTML = '';

        // Create header with back button
        const header = document.createElement('div');
        header.className = 'editor-header';

        const backButton = document.createElement('button');
        backButton.innerHTML = '&larr; Back to Timeline';
        backButton.className = 'btn btn-secondary';
        backButton.onclick = () => {
            mainEditor.style.display = 'none';
            mainTimeline.style.display = 'block';
        };

        const title = document.createElement('h2');
        title.textContent = `${node.name} (${node.id})`;

        header.appendChild(backButton);
        header.appendChild(title);
        mainEditor.appendChild(header);

        // If it's a node with SQL, show the code section
        if (node.code) {
            const codeSection = document.createElement('div');
            codeSection.className = 'code-section';

            const codeTitle = document.createElement('h3');
            codeTitle.textContent = 'SQL Code';

            const codeBlock = document.createElement('pre');
            codeBlock.className = 'sql-code';
            codeBlock.textContent = node.code;

            codeSection.appendChild(codeTitle);
            codeSection.appendChild(codeBlock);
            mainEditor.appendChild(codeSection);
        }

        // If node has schema, show data table
        if (node.schema) {
            const dataSection = document.createElement('div');
            dataSection.className = 'data-section';

            const dataTitle = document.createElement('h3');
            dataTitle.textContent = 'Data Preview';

            const table = document.createElement('table');
            table.className = 'data-table';

            // Create header row
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');

            node.schema.forEach(column => {
                const th = document.createElement('th');
                th.innerHTML = `${column.name}<br><span class="column-type">${column.type}</span>`;
                headerRow.appendChild(th);
            });

            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Create data rows (generate fake data based on schema)
            const tbody = document.createElement('tbody');
            const rowCount = 10;

            // Generate random data based on column types
            const generateValue = (type) => {
                switch (type) {
                    case 'string':
                        return `sample-${Math.random().toString(36).substring(2, 8)}`;
                    case 'integer':
                        return Math.floor(Math.random() * 1000);
                    case 'float':
                        return +(Math.random() * 100).toFixed(2);
                    case 'boolean':
                        return Math.random() > 0.5 ? 'true' : 'false';
                    case 'date':
                        const date = new Date();
                        date.setDate(date.getDate() - Math.floor(Math.random() * 365));
                        return date.toISOString().split('T')[0];
                    default:
                        return 'N/A';
                }
            };

            for (let i = 0; i < rowCount; i++) {
                const dataRow = document.createElement('tr');

                node.schema.forEach(column => {
                    const td = document.createElement('td');
                    td.textContent = generateValue(column.type);
                    dataRow.appendChild(td);
                });

                tbody.appendChild(dataRow);
            }

            table.appendChild(tbody);
            dataSection.appendChild(dataTitle);
            dataSection.appendChild(table);
            mainEditor.appendChild(dataSection);
        }
    }

    // Update sidebar with node configuration
    function updateSidebar(node) {
        const sidebar = document.querySelector('.sidebar');
        const sideHistory = document.getElementById('history');

        sidebar.style.display = 'block';

        // Generate configuration info for sidebar
        let configInfo = `# ${node.name} (${node.id})\n\n`;
        configInfo += `**Type:** ${node.type}\n\n`;
        configInfo += `**Details:** ${node.details}\n\n`;

        if (node.type === 'load' && node.stats) {
            configInfo += `## Statistics\n\n`;
            configInfo += `- Data Stored: ${node.stats.dataStored}\n`;
            configInfo += `- Last Refresh: ${new Date(node.stats.lastRefresh).toLocaleString()}\n`;
            configInfo += `- Avg Refresh Time: ${node.stats.avgRefreshTime}\n`;
            configInfo += `- Query Count: ${node.stats.queryCount.toLocaleString()}\n`;
            configInfo += `- Refresh Frequency: ${node.stats.refreshFrequency}\n\n`;
        }

        if (node.schema) {
            configInfo += `## Schema\n\n`;
            node.schema.forEach(col => {
                configInfo += `- ${col.name} (${col.type})\n`;
            });
        }

        sideHistory.value = configInfo;
    }

    // Populate the Refresh History section
    function populateRefreshes() {
        const refreshesTab = document.querySelector('.tab-content[data-tab="1"]');

        // Clear previous content
        refreshesTab.innerHTML = '';

        // Create all refreshes table
        const allRefreshesSection = document.createElement('div');
        allRefreshesSection.innerHTML = '<h3>All ETL Refreshes</h3>';

        const allRefreshesTable = document.createElement('table');
        allRefreshesTable.className = 'data-table';
        allRefreshesTable.innerHTML = `
        <thead>
            <tr>
                <th>Data Source</th>
                <th>Refresh Time</th>
                <th>Type</th>
                <th>Duration</th>
                <th>Status</th>
            </tr>
        </thead>
        <tbody>
            ${fakeData.refreshHistory.map(refresh => `
                <tr class="${refresh.status === 'Failed' ? 'failed-row' : ''}">
                    <td>${refresh.datasource}</td>
                    <td>${new Date(refresh.refreshTime).toLocaleString()}</td>
                    <td>${refresh.refreshType}</td>
                    <td>${refresh.duration}</td>
                    <td class="status-${refresh.status.toLowerCase()}">${refresh.status}</td>
                </tr>
            `).join('')}
        </tbody>
    `;

        allRefreshesSection.appendChild(allRefreshesTable);
        refreshesTab.appendChild(allRefreshesSection);

        // Create failed processes table
        const failedSection = document.createElement('div');
        failedSection.innerHTML = '<h3>Failed ETL Processes</h3>';

        const failedTable = document.createElement('table');
        failedTable.className = 'data-table';
        failedTable.innerHTML = `
        <thead>
            <tr>
                <th>Data Source</th>
                <th>Failed Step</th>
                <th>Time</th>
                <th>Error Message</th>
            </tr>
        </thead>
        <tbody>
            ${fakeData.failedProcesses.map(failure => `
                <tr>
                    <td>${failure.datasource}</td>
                    <td>${failure.step}</td>
                    <td>${new Date(failure.crashTime).toLocaleString()}</td>
                    <td class="error-message">${failure.errorMessage}</td>
                </tr>
            `).join('')}
        </tbody>
    `;

        failedSection.appendChild(failedTable);
        refreshesTab.appendChild(failedSection);
    }

    // Populate the Performance section
    function populatePerformance() {
        const performanceTab = document.querySelector('.tab-content[data-tab="2"]');

        // Clear previous content
        performanceTab.innerHTML = '';

        // Create metric cards with factory focus
        const metrics = fakeData.performanceMetrics;
        const metricsSection = document.createElement('div');
        metricsSection.className = 'metric-cards';
        
        metricsSection.innerHTML = `
            <div class="metric-card">
                <h3>Production Rate</h3>
                <div class="metric-value">${metrics.avgThroughput}</div>
            </div>
            <div class="metric-card">
                <h3>Sensor Response</h3>
                <div class="metric-value">${metrics.avgLatency}</div>
            </div>
            <div class="metric-card">
                <h3>Defect Rate</h3>
                <div class="metric-value">${metrics.errorRate}</div>
            </div>
            <div class="metric-card">
                <h3>Total Data Volume</h3>
                <div class="metric-value">${metrics.totalDataStored}</div>
            </div>
            <div class="metric-card">
                <h3>Processing Time</h3>
                <div class="metric-value">${metrics.avgPipelineTime}</div>
            </div>
        `;
        
        performanceTab.appendChild(metricsSection);
        
        // Create factory data views table
        const servingSection = document.createElement('div');
        servingSection.innerHTML = '<h3>Factory Data Views</h3>';
        
        const servingTable = document.createElement('table');
        servingTable.className = 'data-table';
        servingTable.innerHTML = `
            <thead>
                <tr>
                    <th>Dashboard</th>
                    <th>Data Volume</th>
                    <th>Last Update</th>
                    <th>Refresh Interval</th>
                    <th>Query Count</th>
                    <th>Refresh Schedule</th>
                </tr>
            </thead>
            <tbody>
                ${fakeData.servingLayers.map(layer => `
                    <tr>
                        <td>${layer.name}</td>
                        <td>${layer.dataStored}</td>
                        <td>${new Date(layer.lastRefresh).toLocaleString()}</td>
                        <td>${layer.avgRefreshTime}</td>
                        <td>${layer.queryCount.toLocaleString()}</td>
                        <td>${layer.refreshFrequency}</td>
                    </tr>
                `).join('')}
            </tbody>
        `;
        
        servingSection.appendChild(servingTable);
        performanceTab.appendChild(servingSection);
    }

    // Mouse move handler
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Handle dragging
        if (isDragging) {
            const dx = mouseX - lastMousePos.x;
            const dy = mouseY - lastMousePos.y;

            panOffset.x += dx;
            panOffset.y += dy;

            // Limit panning
            const maxPan = canvas.width * 0.5;
            panOffset.x = Math.max(Math.min(panOffset.x, maxPan), -maxPan);
            panOffset.y = Math.max(Math.min(panOffset.y, maxPan), -maxPan);

            lastMousePos = { x: mouseX, y: mouseY };
            drawPipeline();
        } else {
            // Check for hover
            const node = getNodeAtPosition(mouseX, mouseY);

            if (node) {
                canvas.style.cursor = 'pointer';
                // Show tooltip
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX + 10) + 'px';
                tooltip.style.top = (e.clientY + 10) + 'px';
                tooltip.textContent = `${node.name}: ${node.details}`;
            } else {
                canvas.style.cursor = 'default';
                tooltip.style.display = 'none';
            }
        }
    });

    // Mouse down handler
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const node = getNodeAtPosition(mouseX, mouseY);

        if (node) {
            selectedNode = node;
            // Show node details in the main view
            renderNodeDetails(node);
            // Update sidebar with node configuration
            updateSidebar(node);
        } else {
            // Start panning
            isDragging = true;
            lastMousePos = { x: mouseX, y: mouseY };
        }
    });

    // Mouse up handler
    canvas.addEventListener('mouseup', () => {
        isDragging = false;
    });

    // Mouse out handler
    canvas.addEventListener('mouseout', () => {
        isDragging = false;
        tooltip.style.display = 'none';
    });

    // Mouse wheel handler for zoom
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();

        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Calculate zoom factor
        const zoom = e.deltaY < 0 ? 1.1 : 0.9;

        // Apply zoom limits
        const newScale = Math.max(0.5, Math.min(2.0, scale * zoom));

        if (newScale !== scale) {
            // Zoom centered on mouse position
            const scaleRatio = newScale / scale;
            panOffset.x = mouseX - scaleRatio * (mouseX - panOffset.x);
            panOffset.y = mouseY - scaleRatio * (mouseY - panOffset.y);

            scale = newScale;
            drawPipeline();
        }
    });

    // Query toggle handler
    queryToggle.addEventListener('change', (e) => {
        showQueries = e.target.checked;
        drawPipeline();
    });

    const style = document.createElement('style');
    style.textContent = `
    .editor-header {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
    }
    
    .editor-header h2 {
        margin-left: 20px;
    }
    
    .code-section {
        margin-bottom: 20px;
    }
    
    .sql-code {
        background-color: #f5f5f5;
        padding: 15px;
        border-radius: 5px;
        overflow-x: auto;
        font-family: monospace;
    }
    
    .data-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
    }
    
    .data-table th, .data-table td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }
    
    .data-table th {
        background-color: #f2f2f2;
    }
    
    .column-type {
        font-size: 0.8em;
        color: #666;
    }
    
    .metric-cards {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .metric-card {
        background-color: #f5f5f5;
        border-radius: 8px;
        padding: 15px;
        min-width: 180px;
        flex: 1;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .metric-card h3 {
        margin-top: 0;
        color: #555;
        font-size: 0.9em;
    }
    
    .metric-value {
        font-size: 1.8em;
        font-weight: bold;
        color: #333;
    }
    
    .failed-row {
        background-color: rgba(255, 200, 200, 0.3);
    }
    
    .status-success {
        color: green;
        font-weight: bold;
    }
    
    .status-failed {
        color: red;
        font-weight: bold;
    }
    
    .error-message {
        color: #d32f2f;
        max-width: 400px;
    }
`;
    document.head.appendChild(style);

    // Setup tab navigation
    document.querySelectorAll('.tab-navigation button').forEach(button => {
        button.addEventListener('click', () => {
            const tabId = button.getAttribute('data-tab');

            // Remove active class from all buttons and tabs
            document.querySelectorAll('.tab-navigation button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });

            // Add active class to current button and tab
            button.classList.add('active');
            document.querySelector(`.tab-content[data-tab="${tabId}"]`).classList.add('active');
        });
    });

    // Initialize tab content
    populateRefreshes();
    populatePerformance();

    // Initial setup
    document.querySelector('.tab-navigation button[data-tab="1"]').click();

    // Initial draw
    drawPipeline();

    // Handle window resize
    window.addEventListener('resize', () => {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        drawPipeline();
    });

</script>